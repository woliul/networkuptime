<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸ’¡ Network Monitor | SQLite in Browser</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <style>
        /* Custom scrollbar for log table */
        #log-body-container::-webkit-scrollbar {
            width: 8px;
        }
        #log-body-container::-webkit-scrollbar-thumb {
            background-color: #cbd5e1; /* slate-300 */
            border-radius: 4px;
        }
        #log-body-container::-webkit-scrollbar-track {
            background: #f1f5f9; /* slate-100 */
        }

        /* * NEW CSS: Status Dot and Pulse Animation
         * We define the pulse here to use in the JS-injected HTML.
         */
        @keyframes pulse-dot-up {
            0% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.7); } /* green-600 */
            70% { box-shadow: 0 0 0 6px rgba(16, 185, 129, 0); }
            100% { box-shadow: 0 0 0 0 rgba(16, 185, 129, 0); }
        }

        @keyframes pulse-dot-down {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); } /* red-500 */
            70% { box-shadow: 0 0 0 4px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }

        .status-dot {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 8px;
            position: relative;

        }

        .status-up .status-dot {
            background-color: #10b981; /* green-500 */
            animation: pulse-dot-up 2s infinite;
        }

        .status-down .status-dot {
            background-color: #ef4444; /* red-500 */
            animation: pulse-dot-down 2s infinite;
        }

        /* * NEW CSS: Styles to match the flat background look
         * We target the status display ID to override its default background and padding.
         */
        #status-display.status-up {
            background-color: transparent !important;
            padding: 0 !important;
            color: #10b981 !important; /* green-500 */
            font-weight: 700; /* bold */
            text-align: right !important;
        }

        #status-display.status-down {
            background-color: transparent !important;
            padding: 0 !important;
            color: #ef4444 !important; /* red-500 */
            font-weight: 700;
            text-align: right !important;
        }

        #status-display.status-default {
            /* Keep original styles for Initializing... state */
            background-color: #e5e7eb; /* gray-200 */
            color: #4b5563; /* gray-700 */
            text-align: center !important;
        }

        /* General layout adjustments to match your image */
        .md\:col-span-1 {
            /* This targets the parent container of the status box */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* Adjusting the header for the status section */
        .md\:col-span-1 h2 {
            font-size: 1.25rem; /* xl */
            font-weight: 700; /* bold */
            color: #1f2937; /* gray-800 */
        }

        /* Adding a subtitle for host (mimicking your image) */
        .status-box-header p {
            font-size: 0.75rem; /* xs */
            color: #6b7280; /* gray-500 */
            margin-bottom: 0.5rem;
        }

        /* Use flexbox to put title/subtitle on left and status on right */
        .status-box-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .card {
            background-color: #1f2937; /* bg-gray-800 */
            border: 1px solid #374151; /* border-gray-700 */
            border-radius: 0.75rem; /* rounded-xl */
            padding: 1.5rem; /* p-6 */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            height: 100%;
        }
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }

    </style>
</head>
<body class="bg-gray-50 p-4 md:p-8 min-h-screen">

<header class="text-center mb-8 md:mb-12">
    <h1 class="text-3xl md:text-4xl text-gray-700 font-bold">Network Monitoring Dashboard</h1>
    <p class="text-text-sm-400 mt-2">Real-time Network Monitoring</p>
</header>

<div class="grid grid-cols-1 gap-6 md:gap-8">

    <div class="card p-8 bg-white border border-gray-200">
        <div class="flex items-center justify-between">
            <div >
                <h2 class="text-3xl font-bold text-gray-700 mb-1">Network Status</h2>
                <p class="text-sm text-gray-500 mb-4">Connectivity Check Host: Google</p>
            </div>

            <div id="status-display" class="p-3 text-center rounded-lg font-extrabold text-2xl transition-colors duration-300 bg-gray-200 text-gray-700 status-default">
                Initializing...
            </div>
        </div>
    </div>
</div>

<div class="card p-8 bg-white border border-gray-200 mt-8">
    <div class="text-xl font-semibold text-gray-800 mb-3 flex justify-between items-center">
        <div class="flex items-center">
            <i class="ph ph-activity icon mr-3"></i>
            <h2 class="text-xl font-semibold">Network Activity Log</h2>
        </div>
        <div class="space-x-2 flex">
            <button id="export-logs-btn" class="flex items-center text-sm px-3 py-1 bg-blue-500 text-white font-medium rounded-lg hover:bg-blue-600 transition duration-150 shadow-sm disabled:opacity-50" disabled>
                <i class="ph ph-download mr-1 text-base "></i> Export CSV
            </button>
            <button id="clear-logs-btn" class="flex items-center text-sm px-3 py-1 bg-amber-500 text-white rounded-lg hover:bg-amber-600 transition duration-150 shadow-sm disabled:opacity-50">
                <i class="ph ph-trash mr-1 text-base"></i> Clear Log
            </button>
        </div>
    </div>

    <div class="border border-indigo-200 rounded-lg overflow-hidden shadow-sm">
        <div class="overflow-x-auto">
            <table class="min-w-full divide-y divide-indigo-200">
                <thead class="bg-indigo-500">
                <tr>
                    <th class="px-6 py-3 text-left text-sm font-medium text-white uppercase tracking-wider w-1/4">
                        ID
                    </th>
                    <th class="px-6 py-3 text-left text-sm font-medium text-white uppercase tracking-wider w-2/4">
                        Timestamp
                    </th>
                    <th class="px-6 py-3 text-left text-sm font-medium text-white uppercase tracking-wider w-1/4">
                        Status
                    </th>
                </tr>
                </thead>
            </table>
        </div>
        <div id="log-body-container" class="max-h-80 overflow-y-auto bg-white">
            <table class="min-w-full divide-y divide-indigo-200">
                <tbody id="log-table-body" class="bg-white divide-y divide-indigo-200">
                <tr>
                    <td colspan="3" class="px-6 py-4 text-sm text-gray-500 text-center">No history yet.</td>
                </tr>
                </tbody>
            </table>
        </div>
    </div>
</div>

<div class="mt-6 pt-4 border-t border-gray-200 text-center text-xs text-gray-400">
    Copyright &copy; <span id="copyright-year"></span> Woliul Hasan. All rights reserved.
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js"></script>

<script>
    // --- CONSTANTS ---
    const DB_NAME = 'networkMonitorDB';
    const DB_STORE_NAME = 'sqliteData';
    const FETCH_TARGET = 'https://www.google.com/favicon.ico'; // Small, reliable file
    const FETCH_TIMEOUT_MS = 5000;
    // Hardcode the interval for permanent auto-monitoring
    const MONITORING_INTERVAL_MS = 1000; // 1 second

    // --- STATE VARIABLES ---
    let SQL;           // Holds the sql.js module
    let db;            // Holds the SQLite database instance
    let monitorInterval = null; // Holds the setInterval ID
    let lastKnownStatus = null; // 'Up' or 'Down'

    // --- DOM ELEMENTS ---
    const statusDisplay = document.getElementById('status-display');
    const clearLogsBtn = document.getElementById('clear-logs-btn');
    const exportLogsBtn = document.getElementById('export-logs-btn');
    const logTableBody = document.getElementById('log-table-body');
    const copyright = document.getElementById('copyright-year');

    // ==============================
    // 1. IndexedDB Persistence Logic (UNMODIFIED)
    // ==============================

    async function saveDbToIndexedDB() {
        if (!db) return;
        const data = db.export();

        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, 1);

            request.onupgradeneeded = function(e) {
                const idb = e.target.result;
                idb.createObjectStore(DB_STORE_NAME);
            };

            request.onsuccess = function(e) {
                const idb = e.target.result;
                const transaction = idb.transaction([DB_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(DB_STORE_NAME);

                const putRequest = store.put(data, 'main');

                putRequest.onsuccess = () => resolve();
                putRequest.onerror = (err) => reject(err);
            };

            request.onerror = (e) => reject(e.target.error);
        });
    }

    async function loadDbFromIndexedDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, 1);

            request.onupgradeneeded = function(e) {
                const idb = e.target.result;
                idb.createObjectStore(DB_STORE_NAME);
            };

            request.onsuccess = function(e) {
                const idb = e.target.result;
                const transaction = idb.transaction([DB_STORE_NAME], 'readonly');
                const store = transaction.objectStore(DB_STORE_NAME);

                const getRequest = store.get('main');

                getRequest.onsuccess = function() {
                    resolve(getRequest.result || null);
                };
                getRequest.onerror = (err) => reject(err);
            };

            request.onerror = (e) => reject(e.target.error);
            request.onblocked = () => { /* Handle blocked state if needed */ };
        });
    }

    async function deleteDbFromIndexedDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, 1);

            request.onupgradeneeded = function(e) {
                const idb = e.target.result;
                if (!idb.objectStoreNames.contains(DB_STORE_NAME)) {
                    idb.createObjectStore(DB_STORE_NAME);
                }
            };

            request.onsuccess = function(e) {
                const idb = e.target.result;
                const transaction = idb.transaction([DB_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(DB_STORE_NAME);

                const deleteRequest = store.delete('main');

                deleteRequest.onsuccess = () => resolve();
                deleteRequest.onerror = (err) => reject(err);
            };

            request.onerror = (e) => reject(e.target.error);
        });
    }

    // ==============================
    // 2. SQL.js Database Operations (UNMODIFIED)
    // ==============================

    async function initDb() {
        try {
            SQL = await initSqlJs({
                locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
            });

            const data = await loadDbFromIndexedDB();

            if (data) {
                db = new SQL.Database(data);
                console.log('Database loaded from IndexedDB.');
            } else {
                db = new SQL.Database();
                db.exec(`
                    CREATE TABLE network_logs (
                                                  id INTEGER PRIMARY KEY AUTOINCREMENT,
                                                  timestamp TEXT NOT NULL,
                                                  status TEXT NOT NULL
                    );
                `);
                console.log('New database created.');
                await saveDbToIndexedDB();
            }

            await updateLogDisplay();
            updateUI(null, 'Initializing...');
            clearLogsBtn.disabled = false;
            exportLogsBtn.disabled = false;

            startMonitoring();

        } catch (error) {
            console.error('Error initializing database:', error);
            alert('Failed to initialize database. Check console for details.');
        }
    }

    function logNetworkStatus(status) {
        if (!db) return;

        const timestamp = new Date().toISOString();
        const statement = db.prepare("INSERT INTO network_logs (timestamp, status) VALUES (?, ?)");

        try {
            statement.run([timestamp, status]);
            saveDbToIndexedDB().catch(e => console.error('Failed to save DB after logging:', e));
            updateLogDisplay();

        } catch (e) {
            console.error('Error executing SQL:', e);
        } finally {
            statement.free();
        }
    }

    // ==============================
    // 3. Network Monitoring Logic (UNMODIFIED)
    // ==============================

    async function isConnected() {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), FETCH_TIMEOUT_MS);

        try {
            await fetch(FETCH_TARGET, {
                method: 'HEAD',
                cache: 'no-store',
                signal: controller.signal,
                mode: 'no-cors'
            });
            clearTimeout(timeoutId);
            return true;
        } catch (error) {
            clearTimeout(timeoutId);
            return false;
        }
    }

    async function performCheck() {
        const isUp = await isConnected();
        const currentStatus = isUp ? 'Up' : 'Down';
        updateUI(currentStatus, `Last checked: ${new Date().toLocaleTimeString()}`);

        if (currentStatus !== lastKnownStatus) {
            logNetworkStatus(currentStatus);
            lastKnownStatus = currentStatus;
        }
    }

    function startMonitoring() {
        if (monitorInterval) return;
        performCheck();
        monitorInterval = setInterval(performCheck, MONITORING_INTERVAL_MS);
        console.log(`Monitoring started automatically at ${MONITORING_INTERVAL_MS / 1000}s interval.`);
    }

    // ==============================
    // 4. UI Functions & Event Handlers
    // ==============================

    /**
     * Exports all logs from the database to a CSV file.
     * Uses local timestamp formatting. (UNMODIFIED)
     */
    function exportLogsToCsv() {
        if (!db) return alert('Database not initialized.');

        try {
            const res = db.exec("SELECT id, timestamp, status FROM network_logs ORDER BY id ASC");

            if (res.length === 0 || res[0].values.length === 0) {
                return alert('No data to export.');
            }

            const rows = res[0].values;
            const columns = res[0].columns;

            let csvContent = columns.join(',') + '\n';
            rows.forEach(row => {
                const [id, isoTimestamp, status] = row;

                const date = new Date(isoTimestamp);

                const formattedTimestamp = date.toLocaleDateString() + ' ' +
                    date.toLocaleTimeString([], { hour12: true, hour: '2-digit', minute: '2-digit', second: '2-digit' });

                const exportRow = [id, formattedTimestamp, status];
                const formattedRow = exportRow.map(value => `"${String(value).replace(/"/g, '""')}"`);
                csvContent += formattedRow.join(',') + '\n';
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");

            const date = new Date().toISOString().slice(0, 19).replace('T', '_').replace(/:/g, '-');
            link.setAttribute("href", url);
            link.setAttribute("download", `network_log_${date}.csv`);

            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            console.log('Logs exported to CSV successfully.');

        } catch (e) {
            console.error('Error exporting logs:', e);
            alert('Failed to export logs. See console for details.');
        }
    }

    /**
     * Updates the main status display element with the new visual style
     * using the pulsing dot. (MODIFIED)
     */
    function updateUI(status, message) {
        let statusContent;
        let statusClasses;

        // 1. Determine Content and New Classes
        if (status === 'Up') {
            // Inject the dot HTML and set text
            statusContent = `<span class="status-dot"></span>UP`;
            // Apply custom classes defined in CSS for the visual style
            statusClasses = 'status-up font-extrabold text-2xl transition-colors duration-300';
        } else if (status === 'Down') {
            statusContent = `<span class="status-dot"></span>Down`;
            statusClasses = 'status-down font-extrabold text-2xl transition-colors duration-300';
        } else {
            // Default/Initializing state
            statusContent = message;
            // Use the base classes for the initial state look
            statusClasses = 'p-3 text-center rounded-lg font-extrabold text-2xl transition-colors duration-300 bg-gray-200 text-gray-700 status-default';
        }

        // 2. Apply Changes
        statusDisplay.className = statusClasses;
        statusDisplay.innerHTML = statusContent; // Use innerHTML to inject the <span> dot
    }


    async function updateLogDisplay() {
        if (!db) return;

        logTableBody.innerHTML = '';

        try {
            const res = db.exec("SELECT id, timestamp, status FROM network_logs ORDER BY id DESC");

            if (res.length === 0 || res[0].values.length === 0) {
                logTableBody.innerHTML = `<tr><td colspan="3" class="px-6 py-4 text-sm text-gray-500 text-center">No history yet.</td></tr>`;
                exportLogsBtn.disabled = true;
                return;
            }

            exportLogsBtn.disabled = false;

            const rows = res[0].values;

            rows.forEach(row => {
                const [id, isoTimestamp, status] = row;
                const date = new Date(isoTimestamp);

                const timeString = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                const dateString = date.toLocaleDateString();

                const statusColor = status === 'Up' ? 'text-green-600 font-semibold' : 'text-red-600 font-semibold';

                const newRow = logTableBody.insertRow();
                newRow.className = 'hover:bg-gray-50';

                let idCell = newRow.insertCell();
                idCell.className = 'px-6 py-2 text-sm font-medium text-gray-900';
                idCell.textContent = id;

                let timestampCell = newRow.insertCell();
                timestampCell.className = 'px-6 py-2 text-sm text-gray-700 font-mono';
                timestampCell.innerHTML = `<span class="block">${dateString}</span><span class="text-xs text-gray-500">${timeString}</span>`;

                let statusCell = newRow.insertCell();
                statusCell.className = `px-6 py-2 text-sm ${statusColor}`;
                statusCell.textContent = status;

                let copyrightYear = date.toLocaleDateString(undefined, { year: 'numeric' });
                copyright.innerHTML = `<span class="font-bold">${copyrightYear}</span>`;
            });

        } catch (e) {
            console.error('Error querying logs:', e);
        }
    }

    async function clearLogs() {
        if (!confirm('Are you sure you want to clear all connection history? This action is irreversible.')) {
            return;
        }

        try {
            db.exec("DROP TABLE IF EXISTS network_logs;");
            db.exec(`
                CREATE TABLE network_logs (
                                              id INTEGER PRIMARY KEY AUTOINCREMENT,
                                              timestamp TEXT NOT NULL,
                                              status TEXT NOT NULL
                );
            `);

            await deleteDbFromIndexedDB();
            await saveDbToIndexedDB();

            lastKnownStatus = null;
            await updateLogDisplay();
            updateUI(null, 'Logs cleared. Monitoring continues automatically.');

            performCheck();

        } catch (error) {
            console.error('Error clearing logs:', error);
            alert('Failed to clear logs. See console for details.');
        }
    }


    // ==============================
    // 5. Initialization
    // ==============================

    clearLogsBtn.addEventListener('click', clearLogs);
    exportLogsBtn.addEventListener('click', exportLogsToCsv);

    clearLogsBtn.disabled = true;
    exportLogsBtn.disabled = true;

    initDb();
    // (6 hours * 60 min * 60 sec * 1000 ms = 21,600,000 ms)
    const AUTO_BACKUP_INTERVAL_MS = 6 * 1000;
    setInterval(saveDbToIndexedDB, AUTO_BACKUP_INTERVAL_MS);
    console.log(`IndexedDB auto-save started at ${AUTO_BACKUP_INTERVAL_MS / 1000 / 6} hour interval.`);


    window.addEventListener('beforeunload', saveDbToIndexedDB);



</script>
</body>
</html>